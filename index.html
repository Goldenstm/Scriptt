<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FC Stickers — Caméra BeReal-like</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#0d0d17;--card:#141428;--muted:#9aa0d6;--accent:#5f6ef8;--glass:rgba(255,255,255,0.03)}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,Arial;color:#fff;background:linear-gradient(180deg,var(--bg),#070712)}

    /* Fullscreen camera style like BeReal */
    .cam-shell{position:fixed;inset:0;display:flex;flex-direction:column;background:#000;z-index:9999}
    .cam-top{height:64px;padding:8px 14px;display:flex;align-items:center;justify-content:space-between}
    .cam-top .time{font-weight:700}

    .cam-view{flex:1;position:relative;overflow:hidden}
    video#camVideo{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;background:#000}

    /* Overlay UI */
    .overlay-ui{position:absolute;inset:0;pointer-events:none}
    .overlay-center{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:auto;display:flex;flex-direction:column;align-items:center;gap:12px}

    .capture-btn{width:92px;height:92px;border-radius:50%;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;border:6px solid rgba(255,255,255,0.14);font-size:28px;color:#fff;cursor:pointer;pointer-events:auto}
    .capture-btn:active{transform:scale(.98)}

    .mini-note{position:absolute;bottom:28px;left:50%;transform:translateX(-50%);pointer-events:auto;color:var(--muted);font-size:13px}

    .thumb-left{position:absolute;left:14px;bottom:28px;pointer-events:auto}
    .switch-right{position:absolute;right:14px;bottom:28px;pointer-events:auto}

    .btn-ghost{padding:8px 10px;border-radius:10px;background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.06);color:#fff}

    .hidden{display:none}

    .message{position:absolute;left:50%;top:12%;transform:translateX(-50%);background:rgba(0,0,0,0.5);padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.05)}

    /* confirmation screen small */
    .confirm-shell{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(3,3,8,0.6),rgba(3,3,8,0.85));z-index:10000}
    .confirm-card{width:94%;max-width:720px;background:var(--card);padding:14px;border-radius:12px;border:1px solid var(--glass);}
    .confirm-img{width:100%;height:60vh;object-fit:cover;border-radius:8px}

    @media(max-width:480px){ .capture-btn{width:82px;height:82px;border:5px solid rgba(255,255,255,0.12);font-size:24px} }
  </style>
</head>
<body>

<!-- Main app skeleton simplified: we focus on camera flow -->
<div id="app">
  <div style="padding:12px;color:var(--muted)">App principale (carte, etc.) — appapelez openCameraMode() pour tester</div>
  <button onclick="openCameraMode()" style="margin:12px;padding:10px 14px">Ouvrir la caméra (test)</button>
</div>

<!-- Camera full-screen shell (hidden until invoked) -->
<div id="cameraShell" class="cam-shell hidden" aria-hidden="true">
  <div class="cam-top">
    <div class="time" id="camTime">--:--</div>
    <div style="display:flex;gap:8px"><div id="flipInfo" class="btn-ghost">Arrière</div></div>
  </div>

  <div class="cam-view">
    <video id="camVideo" autoplay playsinline muted></video>

    <div class="overlay-ui">
      <div class="message hidden" id="camMessage"></div>

      <div class="overlay-center">
        <div id="captureBtn" class="capture-btn" title="Prendre la photo">●</div>
      </div>

      <div class="mini-note">Glisser vers le bas pour quitter</div>

      <div class="thumb-left" id="thumbPreview" style="display:none"><img id="thumbImg" style="width:64px;height:64px;border-radius:8px;object-fit:cover;border:2px solid rgba(255,255,255,0.08)" /></div>

      <div class="switch-right"><button id="closeCam" class="btn-ghost">Fermer</button></div>
    </div>
  </div>
</div>

<!-- Confirmation modal -->
<div id="confirmShell" class="confirm-shell" aria-hidden="true">
  <div class="confirm-card">
    <div style="display:flex;justify-content:space-between;align-items:center"><strong id="confirmType">Type</strong><div id="confirmPts" class="muted">Points</div></div>
    <img id="confirmImage" class="confirm-img" />
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px"><button id="confirmCancel" class="btn-ghost">Annuler</button><button id="confirmSave" class="btn">Enregistrer</button></div>
  </div>
</div>

<script>
  // Robust camera flow for Android Samsung Internet
  // Requirements from Matthieu: open rear camera only, full-screen BeReal-like UI, don't open front+rear simultaneously.

  const cameraShell = document.getElementById('cameraShell');
  const camVideo = document.getElementById('camVideo');
  const captureBtn = document.getElementById('captureBtn');
  const closeCam = document.getElementById('closeCam');
  const camMessage = document.getElementById('camMessage');
  const thumbPreview = document.getElementById('thumbPreview');
  const thumbImg = document.getElementById('thumbImg');
  const camTime = document.getElementById('camTime');

  const confirmShell = document.getElementById('confirmShell');
  const confirmImage = document.getElementById('confirmImage');
  const confirmType = document.getElementById('confirmType');
  const confirmPts = document.getElementById('confirmPts');
  const confirmSave = document.getElementById('confirmSave');
  const confirmCancel = document.getElementById('confirmCancel');

  let stream = null;
  let usingDeviceId = null; // we will prefer rear device id if available
  let pendingType = 'sticker'; // 'sticker' or 'surstick'
  const GAME = { points: { sticker:1, surstick:3 }, swipeThreshold: 60 };

  // Update clock
  function updateClock(){ const d=new Date(); camTime.textContent = d.getHours().toString().padStart(2,'0')+':'+d.getMinutes().toString().padStart(2,'0'); }
  setInterval(updateClock,60000); updateClock();

  // Utility: show temporary message
  function showCamMessage(txt, ms=2000){ camMessage.textContent=txt; camMessage.classList.remove('hidden'); setTimeout(()=>camMessage.classList.add('hidden'),ms); }

  // Helper to stop stream cleanly
  function stopStream(){ try{ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; usingDeviceId=null; camVideo.srcObject=null; } }catch(e){ console.warn('stopStream',e); } }

  // Choose rear camera deviceId if possible
  async function getRearDeviceId(){
    try{
      const devices = await navigator.mediaDevices.enumerateDevices();
      // Prefer device with 'back' or 'rear' in label
      const videoInputs = devices.filter(d => d.kind === 'videoinput');
      if(videoInputs.length===0) return null;
      // Try to find labels indicating back camera (labels may be empty until permission granted)
      const rear = videoInputs.find(d => /back|rear|arrière|postérieur/i.test(d.label));
      if(rear) return rear.deviceId;
      // If no label match, try to pick the last device (often rear is last)
      return videoInputs[videoInputs.length-1].deviceId;
    }catch(e){ console.warn('getRearDeviceId error', e); return null; }
  }

  // Start camera with preference for rear device
  async function startCameraRearOnly(){
    try{
      // First attempt: enumerate to find rear device id
      let deviceId = await getRearDeviceId();
      let constraints;
      if(deviceId){
        constraints = { video: { deviceId: { exact: deviceId } }, audio: false };
      } else {
        // fallback to facingMode ideal
        constraints = { video: { facingMode: { ideal: 'environment' } }, audio: false };
      }

      // Important: call getUserMedia only after UI transition to avoid Android killing the stream
      const s = await navigator.mediaDevices.getUserMedia(constraints);
      stream = s; camVideo.srcObject = s; usingDeviceId = deviceId || 'facing:environment';
      // ensure playback. muted is necessary for autoplay on some browsers
      try{ await camVideo.play(); }catch(playErr){ console.warn('video play failed', playErr); }
      camVideo.style.display='block';
      camMessage.classList.add('hidden');
      return true;
    }catch(err){
      console.error('startCameraRearOnly error', err);
      // If permission denied or error, give clear guidance for Samsung Internet
      if(err && (err.name === 'NotAllowedError' || err.name === 'SecurityError')){
        showCamMessage('Permission caméra refusée. Active la permission dans les paramètres du navigateur.', 4000);
      } else {
        showCamMessage('Impossible d\'accéder à la caméra. Essaie la galerie.', 3000);
      }
      return false;
    }
  }

  // Open camera mode: show UI, wait small transition, then start camera
  async function openCameraMode(){
    // ensure single camera instance
    stopStream();

    cameraShell.classList.remove('hidden'); cameraShell.setAttribute('aria-hidden','false');
    // small CSS transition emulation: wait for paint
    await new Promise(r => requestAnimationFrame(()=>r()));
    // wait a bit for transition/paint to avoid Android auto-stop
    await new Promise(r => setTimeout(r, 360));

    const ok = await startCameraRearOnly();
    if(!ok){
      // fallback: open file input (gallery)
      // create a hidden input and trigger
      const input = document.createElement('input'); input.type='file'; input.accept='image/*'; input.style.display='none';
      input.addEventListener('change', (e)=>{ const f=e.target.files[0]; if(!f) return; const reader=new FileReader(); reader.onload=(ev)=>{ onImageCaptured(ev.target.result); }; reader.readAsDataURL(f); });
      document.body.appendChild(input); input.click();
      setTimeout(()=>input.remove(),2000);
    }
  }

  // Close camera mode: do not kill stream unless forced
  function closeCameraMode(){ stopStream(); cameraShell.classList.add('hidden'); cameraShell.setAttribute('aria-hidden','true'); }

  // Capture logic: draw frame -> show thumbnail + confirmation
  captureBtn.addEventListener('click', ()=>{
    if(!stream){ showCamMessage('Caméra non prête'); return; }
    try{
      const video = camVideo; const canvas = document.createElement('canvas'); canvas.width = video.videoWidth || 1280; canvas.height = video.videoHeight || 720; const ctx = canvas.getContext('2d'); ctx.drawImage(video, 0, 0, canvas.width, canvas.height); const dataUrl = canvas.toDataURL('image/jpeg', 0.85);
      // show small thumb
      thumbImg.src = dataUrl; thumbPreview.style.display='block';
      // stop camera after a short delay to ensure frame captured
      setTimeout(()=>{ stopStream(); }, 220);
      // open confirmation modal
      openConfirmation(dataUrl);
    }catch(err){ console.error('capture error', err); showCamMessage('Erreur capture',2000); }
  });

  function openConfirmation(dataUrl){ confirmImage.src = dataUrl; confirmType.textContent = pendingType === 'surstick' ? 'SURSTICK' : 'STICKER'; confirmPts.textContent = pendingType === 'surstick' ? `+${GAME.points.surstick} pts` : `+${GAME.points.sticker} pts`; confirmShell.style.display='flex'; confirmShell.setAttribute('aria-hidden','false'); }

  confirmCancel.addEventListener('click', ()=>{ confirmShell.style.display='none'; confirmShell.setAttribute('aria-hidden','true'); closeCameraMode(); });

  confirmSave.addEventListener('click', ()=>{
    // Save metadata + thumbnail to localStorage (lightweight)
    const meta = { id: Date.now(), type: pendingType, timestamp: new Date().toISOString() };
    const arr = JSON.parse(localStorage.getItem('stickers_meta')||'[]'); arr.unshift(meta); localStorage.setItem('stickers_meta', JSON.stringify(arr));
    confirmShell.style.display='none'; confirmShell.setAttribute('aria-hidden','true'); closeCameraMode(); alert('Sticker enregistré (demo)');
  });

  closeCam.addEventListener('click', ()=>{ closeCameraMode(); });

  // Swiping behavior on the fixed photo button (existing UI) should set pendingType before opening camera
  // For that we expose a helper to set pendingType and call openCameraMode()
  window.setPendingAndOpen = function(type){ pendingType = type === 'surstick' ? 'surstick' : 'sticker'; openCameraMode(); };

  // Also handle keyboard for testing
  document.addEventListener('keydown', (e)=>{ if(e.key==='c'){ setPendingAndOpen('sticker'); } if(e.key==='s'){ setPendingAndOpen('surstick'); } if(e.key==='Escape'){ closeCameraMode(); } });

  // Visibility handling: stop camera if page hidden
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ stopStream(); } });

  // Expose function for quick testing via button in page
  window.openCameraMode = openCameraMode;

  // If you want the original photo-button swipe integration: call setPendingAndOpen before opening camera
  // e.g. setPendingAndOpen('surstick')
</script>
</body>
</html>
